    ********************************************************************************************************************
    ERROR PAGES
    ********************************************************************************************************************

    /*
    fun getFileName(errorCode: Int): String {
        if (environment.isDevelopment()) {
            return getDevFileName(errorCode)
        }
        val fileReader = FileReaderFactory.create(webRootClass)
        val environmentDirectoryExists = fileReader
            .getFile("errors/${environment.getEnvironmentName()}")
            .exists()
        if (!environmentDirectoryExists) {
            return getDevFileName(errorCode)
        }
        return ""
    }

    private fun getDevFileName(errorCode: Int): String {
        val fileNameErrorCodeFile = "errors/$errorCode.html"
        val errorCodeFileExists = FileReaderFactory.create(webRootClass)
            .getFile(fileNameErrorCodeFile)
            .exists()
        return when (errorCodeFileExists) {
            true -> fileNameErrorCodeFile
            false -> "errors/default.html"
        }
    }

    private fun getErrorFileName(errorCode: Int, environment: Environment): String {
        val path = when (environment.isDevelopment()) {
            true -> "errors"
            false -> "errors/${environment.getEnvironmentName()}"
        }
        val fileNameErrorCodeFile = "$path/$errorCode.html"
        val errorCodeFileExists = FileReaderFactory.create(webRootClass)
            .getFile(fileNameErrorCodeFile)
            .exists()
        return when (errorCodeFileExists) {
            true -> fileNameErrorCodeFile
            false -> "$path/default.html"
        }
    }*/

    ********************************************************************************************************************

        // Check if route has arguments
        val hasArguments = routeMapping.parameters.isNotEmpty()
        // If has arguments
        if (hasArguments) {
            // Create path with parameters
            val pathWithParams = routeMapping.parameters.fold(routeMapping.path) { path, param ->
                "$path/{${param.name}}"
            }
            // Register both GET and POST handlers for the same path
            javalin.getAndPost(pathWithParams, handler)
        }


fun getArguments(parameters: List<Parameter>, ctx: Context): Map<String, String> {
    return parameters.associate { arg ->
        val value = try {
            // Try to find the argument as a path parameter
            ctx.pathParam(arg.name)
        } catch (e: IllegalArgumentException) {
            // If the argument was not path parameter, try the request body
            val postValue = ctx.formParam(arg.name)
            // If the argument was not in the request body, try query parameter
            postValue ?: ctx.queryParam(arg.name) ?: ""
        }
        arg.name to value
    }
}


<plugin>
                <!-- Only needed for IntelliJ IDE compatibility with generated bytecode.
                Can be removed if you only build via command line. If not present
                ClassLoader.getSystemClassLoader().definedPackages generates an error. -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <excludes>
                        <exclude>**/*.java</exclude>
                    </excludes>
                </configuration>
            </plugin>