<!doctype html>
<html lang="en">
<head>
    <title>{{title}}</title>
    <link rel="stylesheet" type="text/css" href="/static/style.css">
    <link rel="stylesheet" type="text/css" href="/static/libs/bootstrap/bootstrap.min.css">
    <script src="/static/libs/bootstrap/bootstrap.bundle.min.js"></script>
    <script src="/static/libs/jquery.min.js"></script>
</head>
<body>
<div class="container">
    {{content}}
</div>
<script>
    /**
     * Manages observer relationships between page elements.
     * Implements the observer pattern to notify observers of changes.
     * Uses data-observer-ids attribute to track which elements observe others
     */
    class PageElementObserver {
        constructor() {
            // Map of element IDs to array of observer IDs
            this.elements = new Map()
            // For each page element
            $("[data-page-element]").each((_, element) => {
                // Wrap the vanilla DOM element in a jQuery object
                const $element = $(element)
                // Get the id of the page element
                const pageElementId = $element.attr("id")
                // Get the ids of the page elements that observe this page element
                const idsOfObservingPageElements = $element.data("observerIds")
                    .split(",") // split on comma
                    .filter(Boolean) // filter out empty strings
                // Register the element with its observers
                this.elements.set(pageElementId, idsOfObservingPageElements)
                console.log(`Registered element ${pageElementId} with observers: ${idsOfObservingPageElements}`)
            })
        }

        /**
         * Notifies all observers of a source element that they should update
         * @param {string} sourceId - ID of element that changed
         */
        notify(sourceId) {
            console.log("Current elements map:", Object.fromEntries(this.elements))
            const sourceObservers = this.elements.get(sourceId) || []
            console.log(`Source ${sourceId} has observers:`, sourceObservers)

            // Process each observer sequentially
            sourceObservers.forEach(observerId => {
                console.log(`Updating observer: ${observerId}`)
                this.triggerUpdate(observerId)
            })
        }

        /**
         * Triggers update event for a specific element
         * Uses custom events for loose coupling between components
         * @param {string} id - ID of element to update
         */
        async triggerUpdate(id) {
            const element = document.getElementById(id)
            if (!element) return

            const path = element.dataset.path
            const args = JSON.parse(element.dataset.arguments)

            try {
                const response = await $.ajax({
                    url: `/${path}`,
                    method: "POST",
                    data: JSON.stringify(args),
                    contentType: "application/json"
                })
                console.log(`Update response for ${id}:`, response)
                // noinspection JSUnresolvedReference
                if (response.success) {
                    $(`#${id}`).html(response.message)
                }
            } catch (error) {
                console.error(`Failed to update ${id}:`, error)
            }
        }
    }

    // Initialize when DOM and all scripts are fully loaded
    document.addEventListener("DOMContentLoaded", () => {
        // Additional safety check for jQuery
        if (typeof $ === "undefined") {
            console.error("jQuery not loaded")
            return
        }

        try {
            window.observer = new PageElementObserver()
        } catch (error) {
            console.error("Failed to initialize observers:", error)
        }
    })
</script>
</body>
</html>